@startuml Password Reset Flow
!theme plain
skinparam sequenceMessageAlign center
skinparam backgroundColor #FEFEFE
skinparam shadowing false

title Password Reset Flow - Forgot Password & Reset Process

actor User
participant "Client App" as Client
participant "Auth Service" as Auth
participant "Email Service" as Email
database MongoDB
database Redis

== Forgot Password Request ==

User -> Client: Click "Forgot Password"
Client --> User: Show password reset form

User -> Client: Enter email address
Client -> Auth: POST /api/v1/auth/forgot-password\n{\n  email: "user@example.com"\n}

Auth -> Auth: Validate email format

Auth -> MongoDB: Find user by email
MongoDB --> Auth: User data or null

note over Auth
  Security: Always return success
  even if email doesn't exist
  (prevents email enumeration)
end note

alt User not found
    Auth -> Auth: Log attempt for monitoring
    Auth --> Client: 200 OK\n{message: "If email exists, reset link sent"}
    Client --> User: Check your email for reset link
else User found
    Auth -> Auth: Check rate limiting\nfor this email
    Auth -> Redis: Check reset attempts\nKey: "reset_attempts:{email}"
    Redis --> Auth: Attempt count
    
    alt Too many requests (>3 per hour)
        Auth -> Redis: Increment counter
        Auth --> Client: 429 Too Many Requests\n{error: "Too many reset requests"}
        Client --> User: Too many attempts.\nPlease try again later
    else Within rate limit
        Auth -> Redis: Increment reset attempts\nKey: "reset_attempts:{email}"\nTTL: 1 hour
        
        Auth -> Auth: Generate reset token\n(secure random 32 bytes)
        Auth -> Auth: Hash reset token\n(SHA256)
        
        Auth -> Redis: Store reset token\nKey: "reset_token:{token_hash}"\nValue: {\n  user_id,\n  email,\n  created_at\n}\nTTL: 1 hour
        Redis --> Auth: Stored
        
        Auth -> Auth: Generate reset URL\nhttps://app.example.com/reset-password?\n  token={reset_token}
        
        Auth -> Email: Send password reset email
        note right
          Email Template:
          
          Subject: Password Reset Request
          
          Hi {user_name},
          
          Click the link below to reset your password:
          {reset_url}
          
          This link expires in 1 hour.
          
          If you didn't request this, ignore this email.
          
          For security, this link can only be used once.
        end note
        
        Email --> Auth: Email sent
        
        Auth -> MongoDB: Log password reset request\n{\n  user_id,\n  ip_address,\n  user_agent,\n  requested_at\n}
        
        Auth --> Client: 200 OK\n{message: "If email exists, reset link sent"}
        Client --> User: Check your email for reset link
    end
end

== Reset Password (via Email Link) ==

User -> User: Check email
User -> User: Click reset link
User -> Client: Opens reset password page\nwith token in URL

Client -> Auth: GET /api/v1/auth/reset-password/verify?\n  token={reset_token}

Auth -> Auth: Hash provided token
Auth -> Redis: Verify reset token\nKey: "reset_token:{token_hash}"
Redis --> Auth: Token data or null

alt Token not found or expired
    Auth --> Client: 400 Bad Request\n{error: "Invalid or expired token"}
    Client --> User: Link expired or invalid.\nRequest a new reset link
else Token valid
    Auth --> Client: 200 OK\n{valid: true}
    Client --> User: Show new password form
end

User -> Client: Enter new password\nand confirm password
Client -> Client: Validate password\n- Min 8 characters\n- Uppercase + lowercase\n- Numbers\n- Special characters
Client -> Client: Check passwords match

Client -> Auth: POST /api/v1/auth/reset-password\n{\n  token: "{reset_token}",\n  new_password: "NewSecure123!",\n  confirm_password: "NewSecure123!"\n}

Auth -> Auth: Hash token
Auth -> Redis: Get reset token data\nKey: "reset_token:{token_hash}"
Redis --> Auth: {user_id, email}

alt Token not found
    Auth --> Client: 400 Bad Request\n{error: "Invalid or expired token"}
    Client --> User: Token expired, try again
else Token valid
    Auth -> Auth: Validate new password\n- Strength requirements\n- Not same as old password\n- Not in common passwords list
    
    alt Password validation fails
        Auth --> Client: 400 Bad Request\n{error: "Password doesn't meet requirements"}
        Client --> User: Show password requirements
    else Password valid
        Auth -> MongoDB: Get user\n{user_id}
        MongoDB --> Auth: User with old password_hash
        
        Auth -> Auth: Compare new password with old\nusing bcrypt compare
        
        alt Same as old password
            Auth --> Client: 400 Bad Request\n{error: "Cannot reuse old password"}
            Client --> User: Choose a different password
        else Different password
            Auth -> Auth: Hash new password\nbcrypt (cost factor 12)
            
            Auth -> MongoDB: Update user password\n{\n  password_hash: new_hash,\n  password_changed_at: now(),\n  force_password_change: false\n}
            MongoDB --> Auth: Password updated
            
            Auth -> Redis: Delete used reset token\nKey: "reset_token:{token_hash}"
            Auth -> Redis: Delete all reset attempts\nfor this email
            
            Auth -> MongoDB: Revoke all refresh tokens\nfor this user\n{revoked_at: now()}
            MongoDB --> Auth: Tokens revoked
            
            Auth -> Redis: Invalidate all sessions\nKey pattern: "session:{user_id}:*"
            Redis --> Auth: Sessions invalidated
            
            Auth -> Email: Send password changed notification
            note right
              Email Template:
              
              Subject: Password Changed
              
              Your password was recently changed.
              
              Time: {timestamp}
              IP: {ip_address}
              Location: {city, country}
              
              If this wasn't you, contact support immediately.
            end note
            
            Auth -> MongoDB: Log security event\n{\n  user_id,\n  event_type: "password_reset",\n  ip_address,\n  user_agent,\n  timestamp\n}
            
            Auth --> Client: 200 OK\n{\n  message: "Password reset successful",\n  redirect_url: "/login"\n}
            Client --> User: Password changed!\nPlease login with new password
        end
    end
end

== Password Change (Authenticated User) ==

note over User, Auth
  Different from password reset:
  User is already logged in and
  knows their current password
end note

User -> Client: Navigate to account settings
Client --> User: Show change password form

User -> Client: Fill form:\n- Current password\n- New password\n- Confirm new password

Client -> Auth: POST /api/v1/auth/change-password\nAuthorization: Bearer {access_token}\n{\n  current_password: "OldPass123!",\n  new_password: "NewSecure123!",\n  confirm_password: "NewSecure123!"\n}

Auth -> Auth: Validate access token
Auth -> Auth: Extract user_id from token

Auth -> MongoDB: Get user\n{user_id}
MongoDB --> Auth: User with password_hash

Auth -> Auth: Verify current password\nusing bcrypt compare

alt Current password incorrect
    Auth -> Redis: Increment failed attempts\nKey: "change_pwd_failed:{user_id}"
    Auth --> Client: 401 Unauthorized\n{error: "Current password incorrect"}
    Client --> User: Current password is wrong
else Current password correct
    Auth -> Auth: Validate new password\n(same rules as reset)
    
    alt New password = current password
        Auth --> Client: 400 Bad Request\n{error: "New password must be different"}
        Client --> User: Choose a different password
    else Passwords different
        Auth -> Auth: Hash new password
        Auth -> MongoDB: Update password\n{\n  password_hash,\n  password_changed_at\n}
        
        Auth -> MongoDB: Revoke all other refresh tokens\n(keep current session)
        Auth -> Email: Send change notification
        Auth -> MongoDB: Log security event
        
        Auth --> Client: 200 OK\n{message: "Password changed"}
        Client --> User: Password updated successfully
    end
end

== Account Recovery (Email Not Accessible) ==

note over User, Auth
  If user cannot access their email,
  they need alternative recovery
end note

User -> Client: Click "Can't access email?"
Client -> Auth: GET /api/v1/auth/recovery-options?\n  email={email}

Auth -> MongoDB: Get user recovery options
MongoDB --> Auth: {\n  has_mfa: true,\n  has_recovery_email: true,\n  has_security_questions: false\n}

Auth --> Client: 200 OK\n{options: ["mfa", "recovery_email"]}
Client --> User: Show recovery options

alt Recovery via MFA
    User -> Client: Select MFA recovery
    Client -> Auth: POST /api/v1/auth/recover/mfa\n{email, mfa_code}
    Auth -> Auth: Verify MFA code
    Auth -> Auth: Generate recovery token
    Auth --> Client: Recovery token
else Recovery via alternate email
    User -> Client: Select alternate email
    Client -> Auth: POST /api/v1/auth/recover/email\n{email}
    Auth -> Auth: Send code to recovery email
    Auth --> Client: Code sent
else Contact support
    User -> Client: Contact support
    Client --> User: Show support contact form
end

== Security Monitoring ==

note over Auth, Redis
  Security Measures:
  
  1. **Rate Limiting**:
     - Max 3 reset requests per hour per email
     - Max 5 reset requests per hour per IP
  
  2. **Token Security**:
     - Cryptographically random tokens (32 bytes)
     - Hashed before storage
     - One-time use only
     - Expire after 1 hour
  
  3. **Email Enumeration Prevention**:
     - Always return success message
     - Same response time regardless
  
  4. **Password Policy**:
     - Min 8 characters
     - Complexity requirements
     - Cannot reuse last 5 passwords
     - Check against breached passwords DB
  
  5. **Audit Logging**:
     - Log all reset requests
     - Log successful resets
     - Log failed attempts
     - Include IP, user agent, timestamp
  
  6. **Session Invalidation**:
     - Revoke all tokens after reset
     - Force re-authentication
  
  7. **Notifications**:
     - Email on password change
     - Include IP and location
     - Alert if suspicious activity
end note

@enduml
