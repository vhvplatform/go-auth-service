@startuml Password Reset Flow

title Password Reset / Forgot Password Flow

actor User
participant "Web Client" as Client
participant "Auth Service" as Auth
participant "Email Service" as Email
database "MongoDB" as DB
database "Redis Cache" as Redis

== Initiate Password Reset ==
User -> Client: Click "Forgot Password"
Client --> User: Show password reset form

User -> Client: Enter email address
Client -> Auth: POST /api/v1/auth/forgot-password\n{email, tenant_id}

Auth -> DB: Find user by email and tenant
DB --> Auth: User data
alt User exists
    Auth -> Auth: Generate reset token\n(cryptographically random, 32 bytes)
    Auth -> Auth: Hash reset token
    Auth -> DB: Store reset token\n{user_id, token_hash, expires_at: now() + 1 hour}
    Auth -> Redis: Rate limit check\nKey: password_reset:{email}\nCheck: max 3 per hour
    alt Rate limit not exceeded
        Auth -> Email: Send password reset email\n{email, reset_token, reset_url}
        Email -> Email: Generate email\nSubject: "Password Reset Request"\nBody: Reset link with token
        Email --> User: Email sent to inbox
        Auth -> Redis: Increment reset counter
        Auth --> Client: {success: true, message: "Check your email"}
    else Rate limit exceeded
        Auth --> Client: {error: "Too many requests, try later"}
    end
else User not found
    note over Auth
      Return success even if user doesn't exist
      to prevent email enumeration attacks
    end note
    Auth --> Client: {success: true, message: "Check your email"}
end

Client --> User: Check your email for reset link

== User Receives Email ==
Email --> User: Email with reset link\nLink: https://app.com/reset-password?token={reset_token}

User -> User: Click reset link
User -> Client: Navigate to reset password page\nwith token in URL

== Validate Reset Token ==
Client -> Auth: GET /api/v1/auth/reset-password/validate?token={token}
Auth -> Auth: Hash provided token
Auth -> DB: Find reset token by hash
DB --> Auth: Token record
alt Token exists and valid
    Auth -> Auth: Check expiration (< 1 hour old)
    alt Not expired and not used
        Auth --> Client: {valid: true, email: "u***@example.com"}
        Client --> User: Show new password form
    else Expired or already used
        Auth -> DB: Mark token as used/expired
        Auth --> Client: {valid: false, error: "Token expired"}
        Client --> User: Token expired, request new one
    end
else Token not found
    Auth --> Client: {valid: false, error: "Invalid token"}
    Client --> User: Invalid link, request new one
end

== Set New Password ==
User -> Client: Enter new password\n(with confirmation)
Client -> Client: Validate password requirements:\n- Min 8 characters\n- Uppercase, lowercase, number, special char
Client -> Auth: POST /api/v1/auth/reset-password\n{token, new_password}

Auth -> Auth: Hash provided token
Auth -> DB: Find reset token
DB --> Auth: Token record with user_id
Auth -> Auth: Validate token (not expired, not used)

alt Token valid
    Auth -> Auth: Validate password strength
    alt Password meets requirements
        Auth -> Auth: Hash new password (bcrypt)
        Auth -> DB: Update user password\nSET password_hash = new_hash
        Auth -> DB: Mark reset token as used\nSET used_at = now()
        
        == Invalidate Existing Sessions ==
        Auth -> DB: Revoke all refresh tokens for user\nSET revoked_at = now()
        Auth -> Redis: Delete all user sessions\nDEL session:{user_id}*
        
        == Send Notification ==
        Auth -> Email: Send password changed notification
        Email --> User: "Your password was changed"
        
        Auth -> DB: Log security event\n{user_id, event: "password_reset", timestamp}
        Auth --> Client: {success: true}
        Client --> User: Password reset successful!\nPlease login with new password
    else Password too weak
        Auth --> Client: {error: "Password doesn't meet requirements"}
        Client --> User: Show password requirements
    end
else Token invalid
    Auth --> Client: {error: "Invalid or expired token"}
    Client --> User: Token invalid, request new one
end

== Login with New Password ==
User -> Client: Navigate to login page
User -> Client: Enter email and new password
Client -> Auth: POST /api/v1/auth/login\n{email, password}
Auth -> DB: Verify credentials
Auth -> Auth: Password matches new hash
Auth -> Auth: Generate new JWT tokens
Auth --> Client: {access_token, refresh_token}
Client --> User: Login successful

== Change Password (Authenticated) ==
note over User, Auth
  User can also change password
  while logged in
end note

User -> Client: Go to settings, change password
User -> Client: Enter current password\nand new password
Client -> Auth: POST /api/v1/auth/change-password\n{current_password, new_password}\nHeader: Authorization: Bearer {token}

Auth -> Auth: Extract user_id from token
Auth -> DB: Get user data
DB --> Auth: User with password hash
Auth -> Auth: Verify current password
alt Current password correct
    Auth -> Auth: Validate new password strength
    Auth -> Auth: Hash new password
    Auth -> DB: Update password
    Auth -> Email: Send notification
    Auth --> Client: {success: true}
    Client --> User: Password changed successfully
else Current password wrong
    Auth -> Redis: Track failed attempts\nKey: pwd_change_fail:{user_id}
    Auth --> Client: {error: "Current password incorrect"}
    Client --> User: Incorrect password
end

== Security Features ==
note over Auth, Email
  1. Rate limiting (3 resets per hour)
  2. Token expiration (1 hour)
  3. One-time use tokens
  4. Cryptographically secure tokens
  5. Token hashing in database
  6. Email obfuscation (u***@example.com)
  7. Prevent email enumeration
  8. Session invalidation on reset
  9. Email notifications
  10. Password strength validation
  11. Audit logging
end note

@enduml
